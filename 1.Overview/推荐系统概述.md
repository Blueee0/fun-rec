## 推荐系统概述

### 推荐系统的架构

#### 系统架构

![推荐系统的系统架构](https://datawhalechina.github.io/fun-rec/imgs/ch01/ch1.2/image-20220409204658032.png)

1. 在线层（使用实时数据，保证实时在线服务）

   - 定义：客户端和服务端的实时数据处理，工程师需要主动记录数据，行业术语叫做埋点，主要是后端和客户端完成。
   - 处理内容：
     - 模型在线服务：包括了快速召回和排序；
     - 在线特征快速处理拼接：根据传入的用户ID和场景，快速读取特征和处理；
     - AB实验或者分流：根据不同用户采用不一样的模型，比如冷启动用户和正常服务模型；
     - 运筹优化和业务干预：比如要对特殊商家流量扶持、对某些内容限流；

   - 部署方式：

     - 用RESTful/RPC等提供服务，使用Docker在K8S部署。

       

2. 近线层（使用实时数据，不保证实时响应）

   - 定义：流处理平台准实时数据处理，一般是通过消息队列加在线缓存的方式做成准实时。

   - 处理内容：

     - 特征的事实更新计算：例如统计用户对不同type的ctr，推荐系统一个老生常谈的问题就是特征分布不一致怎么办，如果使用离线算好的特征就容易出现这个问题。近线层能够获取实时数据，按照用户的实时兴趣计算就能很好避免这个问题。

     - 实时训练数据的获取：比如在使用DIN、DSIN这行网络会依赖于用户的实时兴趣变化，用户几分钟前的点击就可以通过近线层获取特征输入模型。

     - 模型实时训练：可以通过在线学习的方法更新模型，实时推送到线上；

   ![近线层](D:/coding/my_cans/fun-rec/1.Overview/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.assets/image-20220409205830027.jpeg)

3. 离线层（不用实时数据，不提供实时响应）

   - 定义：离线数据处理，例如处理数据关联等。
   - 处理内容：
     - 数据处理、数据存储；
     - 特征工程、离线特征计算；
     - 离线模型的训练；

   ![离线层](D:/coding/my_cans/fun-rec/1.Overview/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.assets/image-20220409205904314.jpeg)

#### 算法架构

<img src="D:/coding/my_cans/fun-rec/1.Overview/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.assets/image-20250215190416295.png" alt="image-20250215190416295" style="zoom:67%;" />

1. **召回：实现低延迟，不可遗漏**

   从推荐池中选取几千上万的item，送给后续的排序模块。由于召回面对的候选集十分大，且一般需要在线输出，故召回模块必须轻量快速低延迟。由于后续还有排序模块作为保障，召回不需要十分准确，但不可遗漏（特别是搜索系统中的召回模块）。

   目前基本上采用多路召回解决范式，分为非个性化召回和个性化召回。个性化召回又有content-based、behavior-based、feature-based等多种方式。

   - 相关内容：
     1. 考虑用户层面：用户兴趣的多元化，用户需求与场景的多元化：例如：新闻需求，重大要闻，相关内容沉浸阅读等等
     2. 考虑系统层面：增强系统的鲁棒性；部分召回失效，其余召回队列兜底不会导致整个召回层失效；排序层失效，召回队列兜底不会导致整个推荐系统失效
     3. 系统多样性内容分发：图文、视频、小视频；精准、试探、时效一定比例；召回目标的多元化，例如：相关性，沉浸时长，时效性，特色内容等等
     4. 可解释性推荐一部分召回是有明确推荐理由的：很好的解决产品性数据的引入；

2. **粗排：兼顾低延迟和精准性**

   粗拍的原因是有时候召回的结果还是太多，精排层速度还是跟不上，所以加入粗排。粗排可以理解为精排前的一轮过滤机制，减轻精排模块的压力。粗排介于召回和精排之间，要同时兼顾精准性和低延迟。一般模型也不能过于复杂。

   - 相关内容：
     1. 根据精排模型中的重要特征，来做候选集的截断
     2. 召回设计，比如热度或者语义相关的这些结果，仅考虑了item侧的特征，可以用粗排模型来排序跟当前User之间的相关性，据此来做截断，这样是比单独的按照item侧的倒排分数截断得到更加个性化的结果
     3. 算法的选型，要在在线服务的性能上有保证，因为这个阶段在pipeline中完成从召回到精排的截断工作，在延迟允许的范围内能处理更多的召回候选集理论上与精排效果正相关。

3. **精排：实现精准性**

   获取粗排模块的结果，对候选集进行打分和排序。精排需要在最大时延允许的情况下，保证打分的精准性，是整个系统中至关重要的一个模块，也是最复杂，研究最多的一个模块。精排系统构建一般需要涉及样本、特征、模型三部分。使用AUC作为指标

4. **重排：优化**

   常见的有三种优化目标：Point Wise、Pair Wise 和 List Wise。获取精排的排序结果，基于运营策略、多样性、context上下文等，重新进行一个微调。比如三八节对美妆类目商品提权，类目打散、同图打散、同卖家打散等保证用户体验措施。重排中规则比较多，但目前也有不少基于模型来提升重排效果的方案。

5. **混排：业务逻辑**

   多个业务线都想在Feeds流中获取曝光，则需要对它们的结果进行混排。比如推荐流中插入广告、视频流中插入图文和banner等。可以基于规则策略（如广告定坑）和强化学习来实现。



### 推荐系统的技术栈

1. **画像层**

   - 文本理解：分析item的标题、正文、OCR、评论等数据，算法有：RNN、TextCNN、FastText、Bert等
   - 关键词标签：对item选取最合适的关键词或者标签，算法有：TF-IDF、Bert、LSTM-CRF等。
   - 内容理解：理解视频/图片内容，算法有：TSN、RetinaFace、PSENet等。

   - 知识图谱：知识图谱作为知识承载系统，用于对接内外部关键词信息与词关系信息，算法有：KGAT、RippleNet等。

2. **召回/粗排**

   - 经典模型召回

     通过某种算法，对user和item分别打上Embedding，然后user与item在线进行KNN计算实时查询最近领结果作为召回结果，快速找出匹配的物品。需要注意的是如果召回采用模型召回方法，优化目标最好和排序的优化目标一致，否则可能被过滤掉。

     在这方面典型的算法有：FM、双塔DSSM、Multi-View DNN等。

   - 序列模型召回

     在召回阶段，如何根据用户行为序列打 embedding，可以采取有监督的模型，比如 Next Item Prediction 的预测方式即可；也可以采用无监督的方式，比如物品只要能打出 embedding，就能无监督集成用户行为序列内容，例如 Sum Pooling。

     这方面典型的算法有：CBOW、Skip-Gram、GRU、Bert等。

   - 用户序列拆分

     用户往往是多兴趣的，比如可能同时对娱乐、体育、收藏感兴趣。这些不同的兴趣也能从用户行为序列的物品构成上看出来，比如行为序列中大部分是娱乐类，一部分体育类，少部分收藏类等。用户多兴趣拆分就是解决这类更细致刻画用户兴趣的方向。

     目前常用的拆分用户兴趣 embedding 的方法，主要是胶囊网络和 Memory Network。这方面典型的算法有：Multi-Interest Network with Dynamic Routing for Recommendation at Tmall等。

   - 知识图谱

     知识图谱有一个独有的优势和价值，那就是对于推荐结果的可解释性；比如推荐给用户某个物品，可以在知识图谱里通过物品的关键关联路径给出合理解释。

     这方面的算法有：KGAT、RippleNet等。

   - 图模型

     图神经网络模型推荐就是使用一张复杂的异构图来表示整个推荐系统，把异构网络中包含的结构和语义信息编码到结点Embedding表示中，并使用得到向量进行个性化推荐。

     这方面典型的算法有：GraphSAGE、PinSage等。

3. **精排**

   - 特征交叉模型

     很多论文聚焦于如何提升模型的特征组合和交叉的能力，这其中既包含隐式特征交叉Deep Crossing也有采用显式特征交叉的探究。本质上是希望模型能够摆脱人工先验的特征工程，实现端到端的一套模型。

     这方面的经典研究工作有：DCN、DeepFM、xDeepFM等

   - 序列模型

     在序列建模中，主要任务目标是得到用户此刻的兴趣向量（user interest vector）。如何刻画用户兴趣的广泛性，是推荐系统比较大的一个难点，用户历史行为序列建模的研究经历了从Pooling、RNN到attention、capsule再到transformer的顺序。

     这方面典型的研究工作有：DIN、DSIN、DIEN、SIM等；

   - 多模态信息融合

     传统做法在多模态信息融合就是希望把不同模态信息利用起来，通过Embedding技术融合进模型。在推荐领域，主流的做法还是一套非端到端的体系，由其他模型抽取出多模态信息，推荐只需要融合入这些信息就好了。同时也有其他工作是利用注意力机制等方法来学习不同模态之间的关联，来增强多模态的表示。

     比较典型的工作有：Image Matters: Visually modeling user behaviors using Advanced Model Server、UMPR等。

   - 多任务学习

     很多场景下我们模型优化的目标都是CTR，有一些场景只考虑CTR是不够的，点击率模型、时长模型和完播率模型是大部分信息流产品推荐算法团队都会尝试去做的模型。单独优化点击率模型容易推出来标题党，单独优化时长模型可能推出来的都是长视频或长文章，单独优化完播率模型可能短视频短图文就容易被推出来，所以多目标就应运而生。信息流推荐中，我们不仅希望用户点进我们的item，还希望能有一个不错的完播率，即希望用户能看完我们推荐的商品。或者电商场景希望用户不仅点进来，还希望他买下或者加入购物车了。这些概率实际上就是模型要学习的目标，多种目标综合起来，包括阅读、点赞、收藏、分享等等一系列的行为，归纳到一个模型里面进行学习，这就是推荐系统的多目标学习。

     这方面比较典型的算法有：ESSM、MMoE、DUPN等。

   - 强化学习

     强化学习与一般有监督的深度学习相比有一些很显著的优势，首先强化学习能够比较灵活的定义优化的业务目标，考虑推荐系统长短期的收益，比如用户留存，在深度模型下，我们很难设计这个指标的优化函数，而强化学习是可以对长期收益下来建模。第二是能够体现用户兴趣的动态变化，比如在新闻推荐下，用户兴趣变化很快，强化学习更容易通过用户行为动态产生推荐结果。最后是EE也就是利用探索机制，这种一种当前和长期收益的权衡，强化学习能够更好的调节这里的回报。

     这方面比较典型的算法有：DQN、Reinforcement Learning for Slate-based Recommender Systems: A Tractable Decomposition and Practical Methodology；

   - 跨域推荐

     在跨域推荐中，我们更要关心在不同领域间要选择何种信息进行迁移，以及如何迁移这些信息，这是跨域推荐系统中非常关键的问题。

     这方面典型的模型有：DTCDR、MV-DNN、EMCDR等；

   

   

