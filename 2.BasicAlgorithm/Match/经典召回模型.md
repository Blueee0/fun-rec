# 经典召回模型

召回算法的主要目的是从海量的候选项目（如商品、文章、视频等）中快速筛选出一部分与用户可能感兴趣的项目相关的候选集。

[TOC]

## 基于协同过滤的召回 （Collaborative Filtering）

- 根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品。
  - 基于对用户历史行为数据的挖掘发现用户的喜好偏向， 并预测用户可能喜好的产品进行推荐。
  - 一般是仅仅**基于用户的行为数据**（评价、购买、下载等）, 而不依赖于项的任何附加信息（物品自身特征）或者用户的任何附加信息（年龄， 性别等）。

### 相似性度量法

- 给用户推荐和他兴趣相似的其他用户喜欢的产品。

1. **杰卡德（Jaccard）相似系数**：评估用户是否会打分、隐式反馈数据（0-1）
   $$
   sim_{uv}=\frac{|N(u)\cap N(v)|}{|N(u)|\cup|N(v)|}
   $$

   - 其中 `N(u)`，`N(v)` 分别表示用户 `u` 和用户 `v` 交互物品的集合。
   - 对于用户`u` 和 `v` ，该公式反映了两个交互物品交集的数量占这两个用户交互物品并集的数量的比例。

   由于杰卡德相似系数一般无法反映具体用户的评分喜好信息，所以常用来评估用户是否会对某物品进行打分， 而不是预估用户会对某物品打多少分。

2. **余弦相似度**：度量文本相似度、用户相似度、物品相似度
   $$
   sim_{uv}=\frac{|N(u)\cap N(v)|}{\sqrt{|N(u)|\cdot|N(v)|}}
   $$

   ```python
   from sklearn.metrics.pairwise import cosine_similarity
   
   i = [1, 0, 0, 0]
   j = [1, 0, 1, 0]
   cosine_similarity([i, j])
   ```


3. **皮尔逊相关系数**：不适合用作计算布尔值向量（0-1）之间相关度
   $$
   sim(u,v)=\frac{\sum_{i\in I}(r_{ui}-\bar{r}_u)(r_{vi}-\bar{r}_v)}{\sqrt{\sum_{i\in I}(r_{ui}-\bar{r}_u)^2}\sqrt{\sum_{i\in I}(r_{vi}-\bar{r}_v)^2}}
   $$

   - 其中，rui和rvi 分别表示用户 *u* 和用户 *v* 对物品 *i* 是否有交互(或具体评分值)；

   - *r*ˉ*u*,*r*ˉ*v* 分别表示用户 u*u* 和用户 v*v* 交互的所有物品交互数量或者评分的平均值；

   ```python
   from scipy.stats import pearsonr
   
   i = [1, 0, 0, 0]
   j = [1, 0.5, 0.5, 0]
   pearsonr(i, j)
   ```



### 权重优化

- base 公式
  $$
  w_{ij}=\frac{|N(i)\bigcap N(j)|}{|N(i)|}
  $$

  - 该公式表示同时喜好物品 *i* 和物品 j* 的用户数，占喜爱物品 *i* 的比例。
  - 缺点：若物品 *j* 为热门物品，那么它与任何物品的相似度都很高。

- 对热门物品进行惩罚
  $$
  w_{ij}=\frac{|N(i)\cap N(j)|}{\sqrt{|N(i)||N(j)|}}
  $$

  - 根据 base 公式在的问题，对物品 *j* 进行打压。打压的出发点很简单，就是在分母再除以一个物品 *j* 被购买的数量。
  - 此时，若物品 *j* 为热门物品，那么对应的 N(j) 也会很大，受到的惩罚更多。

- 控制对热门物品的惩罚力度
  $$
  w_{ij}=\frac{|N(i)\cap N(j)|}{|N(i)|^{1-\alpha}|N(j)|^\alpha}
  $$

  - 除了第二点提到的办法，在计算物品之间相似度时可以对热门物品进行惩罚外。
  - 可以在此基础上，进一步引入参数 α* ，这样可以通过控制参数 α*来决定对热门物品的惩罚力度。

- 对活跃用户的惩罚
  $$
  w_{ij}=\frac{\sum_{\mathrm{u\in N(i)\cap N(j)}}\frac{1}{\log1+|N(u)|}}{|N(i)|^{1-\alpha}|N(j)|^\alpha}
  $$

  - 在计算物品之间的相似度时，可以进一步将用户的活跃度考虑进来。

  - 对于异常活跃的用户，在计算物品之间的相似度时，他的贡献应该小于非活跃用户。

    

### 基于用户的协同过滤（UserCF）

- **基本思想**

  如果我们要对用户 A 进行物品推荐，可以先找到和他有相似兴趣的其他用户

  然后，将共同兴趣用户喜欢的，但用户 A 未交互过的物品推荐给 A。

  <img src="D:/coding/my_cans/fun-rec/2.BasicAlgorithm/Match/%E7%BB%8F%E5%85%B8%E5%8F%AC%E5%9B%9E%E6%A8%A1%E5%9E%8B.assets/image-20250218115946124.png" alt="image-20250218115946124" style="zoom: 67%;" />

- **具体过程**

  1. 计算用户之间的相似度

     - Jaccard相似系数、余弦相似度、皮尔逊相关系数

  2. 计算用户对新物品的评分预测

     - 利用目标用户与相似用户之间的相似度以及相似用户对物品的评分，来预测目标用户对候选物品的评分估计
       $$
       R_\mathrm{u,p}=\frac{\sum_{\mathrm{s}\in S}\left(w_\mathrm{u,s}\cdot R_\mathrm{s,p}\right)}{\sum_{\mathrm{s}\in S}w_\mathrm{u,s}}
       $$
       权重 wus 是用户 *u* 和用户 *s* 的相似度， Rs,p 是用户 *s* 对物品 *p* 的评分。

     - 排除用户评分偏置
       $$
       R_{\mathrm{u,p}}=\bar{R}_u+\frac{\sum_{\mathrm{s}\in S}\left(w_{\mathrm{u,s}}\cdot\left(R_{s,p}-\bar{R}_s\right)\right)}{\sum_{\mathrm{s}\in S}w_{\mathrm{u,s}}}
       $$
       其中，Rˉs表示用户 *s* 对物品的历史平均评分

  3. 对用户进行物品推荐

     - 在获得用户 u 对不同物品的评价预测后， 最终的推荐列表根据预测评分进行排序得到。

       

- **算法评价**

  - 召回率：在模型召回预测的物品中，预测准确的物品占用户实际喜欢的物品的比例。
    $$
    \mathrm{Recall}=\frac{\sum_u|R(u)\cap T(u)|}{\sum_u|T(u)|}
    $$

  - 精确率：推荐的物品中，对用户准确推荐的物品占总物品的比例。
    $$
    \mathrm{Precision}=\frac{\sum_u\mid R(u)\cap T(u)|}{\sum_u|R(u)|}
    $$

  - 覆盖率：推荐系统能够推荐出来的物品占总物品集合的比例。

    覆盖率反映了推荐算法发掘长尾的能力， 覆盖率越高， 说明推荐算法越能将长尾中的物品推荐给用户。
    $$
    \mathrm{Coverage~}=\frac{\left|\bigcup_{u\in U}R(u)\right|}{|I|}
    $$

  - 新颖度：用推荐列表中物品的平均流行度，度量推荐结果的新颖度。 

    - 如果推荐出的物品都很热门， 说明推荐的新颖度较低。 由于物品的流行度分布呈长尾分布， 所以为了流行度的平均值更加稳定， 在计算平均流行度时对每个物品的流行度取对数。

      

- **算法缺陷**

  1. 数据稀疏性：用户购买重叠率低

     - 一个大型的电子商务推荐系统一般有非常多的物品，用户可能买的其中不到1%的物品，不同用户之间买的物品重叠性较低，导致算法无法找到一个用户的邻居，即偏好相似的用户。

     - 这导致UserCF不适用于那些正反馈获取较困难的应用场景(如酒店预订， 大件物品购买等低频应用)。

  2. 算法扩展性：维护相似度矩阵，存储空间开销大

     - 需要维护用户相似度矩阵，以便快速的找出 TopN相似用户， 该矩阵的存储开销非常大，存储空间随着用户数量的增加而增加。所以，不适合用户数据量大的情况使用。

       

### 基于物品的协同过滤（ItemCF）

- **基本思想**

  不是计算物品内容属性的相似度，而是主要通过分析用户的行为记录计算物品之间的相似度。

  例如， 物品 A 和物品 C 具有很大的相似度，是因为喜欢物品 A 的用户极可能喜欢物品 C。

  <img src="D:/coding/my_cans/fun-rec/2.BasicAlgorithm/Match/%E7%BB%8F%E5%85%B8%E5%8F%AC%E5%9B%9E%E6%A8%A1%E5%9E%8B.assets/image-20250218132329804.png" alt="image-20250218132329804" style="zoom: 67%;" />

- **具体过程**

  1. 首先计算一下 物品5 和 Alice购买过的物品1,2,3,4 之间的相似性。
  2. 在Alice购买过的物品中，找出与物品 5 最相近的 n 个物品。
  3. 根据 Alice 对最相近的 n 个物品的打分去计算对物品 5 的打分情况。

- **算法评价**

  - 召回率：在模型召回预测的物品中，预测准确的物品占用户实际喜欢的物品的比例。
    $$
    \mathrm{Recall}=\frac{\sum_u|R(u)\cap T(u)|}{\sum_u|T(u)|}
    $$

  - 精确率：推荐的物品中，对用户准确推荐的物品占总物品的比例。
    $$
    \mathrm{Precision}=\frac{\sum_u\mid R(u)\cap T(u)|}{\sum_u|R(u)|}
    $$

  - 覆盖率：推荐系统能够推荐出来的物品占总物品集合的比例。

    覆盖率反映了推荐算法发掘长尾的能力， 覆盖率越高， 说明推荐算法越能将长尾中的物品推荐给用户。
    $$
    \mathrm{Coverage~}=\frac{\left|\bigcup_{u\in U}R(u)\right|}{|I|}
    $$

  - 新颖度：用推荐列表中物品的平均流行度，度量推荐结果的新颖度。 

    - 如果推荐出的物品都很热门， 说明推荐的新颖度较低。 由于物品的流行度分布呈长尾分布， 所以为了流行度的平均值更加稳定， 在计算平均流行度时对每个物品的流行度取对数。

      

- **算法缺陷**

  1. 泛化能力弱：

     - 即协同过滤无法将两个物品相似的信息推广到其他物品的相似性上。
     - 导致的问题是**热门物品具有很强的头部效应， 容易跟大量物品产生相似， 而尾部物品由于特征向量稀疏， 导致很少被推荐**。

  2. 由于未使用更丰富的用户和物品特征信息，这也导致协同过滤算法的模型表达能力有限。

     

### Swing(Graph-based)

- **基本思想：寻找互补商品**

  之前算法对互补性产品的建模不足，可能会导致用户购买过手机之后还继续推荐手机，但用户短时间内不会再继续购买手机，因此产生无效曝光。所以，Swing 算法利用 user-item 二部图的子结构捕获产品间的替代关系。

  E.g.图中的红色四边形就是一种Swing子结构，这种子结构可以作为给王五推荐尿布的依据。

  <img src="D:/coding/my_cans/fun-rec/2.BasicAlgorithm/Match/%E7%BB%8F%E5%85%B8%E5%8F%AC%E5%9B%9E%E6%A8%A1%E5%9E%8B.assets/image-20250218134153413.png" alt="image-20250218134153413" style="zoom:67%;" />

- **计算公式**
  $$
  s(i,j)=\sum_{u\in U_i\cap U_j}\sum_{v\in U_i\cap U_j}w_u*w_v*\frac{1}{\alpha+|I_u\cap I_v|}
  $$
  其中Ui是点击过商品i的用户集合，Iu 是用户u点击过的商品集合，α是平滑系数。

  $w_u=\frac{1}{\sqrt{|I_u|}},w_v=\frac{1}{\sqrt{|I_v|}}$是用户权重参数，来降低活跃用户的影响。

- **改进：Surprise算法**

  - 类别层面
    
    - 由于类别直接的种类差异，每个类别的相关类数量存在差异，因此采用最大相对落点来作为划分阈值。
    
    - 例如图(a)中T恤的相关类选择前八个，图(b)中手机的相关类选择前三个。
    
      <img src="D:/coding/my_cans/fun-rec/2.BasicAlgorithm/Match/%E7%BB%8F%E5%85%B8%E5%8F%AC%E5%9B%9E%E6%A8%A1%E5%9E%8B.assets/image-20250218141121625.png" alt="image-20250218141121625" style="zoom:67%;" />
    
  - 商品层面

    - 考虑商品的购买顺序，例如在用户购买手机后推荐充电宝是合理的，但在用户购买充电宝后推荐手机是不合理的。

    - 考虑两个商品购买的时间间隔，时间间隔越短越能证明两个商品的互补关系。
  
  - 聚类层面
  
    - 如何聚类？ 传统的聚类算法（基于密度和 k-means ）在数十亿产品规模下的淘宝场景中不可行，所以作者采用了标签传播算法。
    - 在哪里标签传播？ Item-item 图，其中有 Swing 计算的排名靠前 item 为邻居，边的权重就是 Swing 分数。
    - 表现如何？ 快速而有效，15分钟即可对数十亿个项目进行聚类。 最终聚类层面的相关度计算同上面商品层面的计算公式
  

### 矩阵分解（隐语义模型）

- **基本思想**

  隐语义模型，就是先通过一些角度把用户兴趣和这些书归一下类， 当来了用户之后， 首先得到他的兴趣分类， 然后从这个分类中挑选他可能喜欢的书籍。

  <img src="D:/coding/my_cans/fun-rec/2.BasicAlgorithm/Match/%E7%BB%8F%E5%85%B8%E5%8F%AC%E5%9B%9E%E6%A8%A1%E5%9E%8B.assets/image-20250218142538819.png" alt="image-20250218142538819" style="zoom:67%;" />

- **计算过程**

  1. 基于评分矩阵，将其分解成Q和P两个矩阵乘积的形式，获取用户兴趣和物品的隐向量表达。

     - 一般而言， k越大，隐向量能承载的信息内容越多，表达能力也会更强，但相应的学习难度也会增加。
     - 所以，我们需要根据训练集样本的数量去选择合适的数值，在保证信息学习相对完整的前提下，降低模型的学习难度。

     <img src="D:/coding/my_cans/fun-rec/2.BasicAlgorithm/Match/%E7%BB%8F%E5%85%B8%E5%8F%AC%E5%9B%9E%E6%A8%A1%E5%9E%8B.assets/image-20250218142416958.png" alt="image-20250218142416958"  />

  2. 然后，基于两个分解矩阵去预测某个用户对某个物品的评分了。
     $$
     
     $$

  3. 最后，基于预测评分去进行物品推荐。

- **具体算法实现**

  - FunkSVD

    **把求解上面两个矩阵的参数问题转换成一个最优化问题， 可以通过训练集里面的观察值利用最小化来学习用户矩阵和物品矩阵**

    [funksvd](https://datawhalechina.github.io/fun-rec/#/ch02/ch2.1/ch2.1.1/mf?id=funksvd)

  - BiasSVD

    提出了另一种LFM， 在原来的基础上加了偏置项， 来消除用户和物品打分的偏差

    [biasSVD](https://datawhalechina.github.io/fun-rec/#/ch02/ch2.1/ch2.1.1/mf?id=biassvd)

- **算法评价**

  - 优点：
    - 泛化能力强： 一定程度上解决了稀疏问题
    - 空间复杂度低： 由于用户和物品都用隐向量的形式存放， 少了用户和物品相似度矩阵， 空间复杂度由n2*n*2降到了(n+m)∗f(*n*+*m*)∗*f*
    - 更好的扩展性和灵活性：矩阵分解的最终产物是用户和物品隐向量， 这个深度学习的embedding思想不谋而合， 因此矩阵分解的结果非常便于与其他特征进行组合和拼接， 并可以与深度学习无缝结合。

  - 缺点：

    - 矩阵分解算法依然是只用到了评分矩阵， 没有考虑到用户特征， 物品特征和上下文特征， 这使得矩阵分解丧失了利用很多有效信息的机会。

    - 同时在缺乏用户历史行为的时候， 无法进行有效的推荐。

    - 为了解决这个问题， **逻辑回归模型及后续的因子分解机模型**， 凭借其天然的融合不同特征的能力， 逐渐在推荐系统领域得到了更广泛的应用。

      

## 基于向量的召回



## 总结

| 算法名称 | 算法类别 | 使用场景                                             | 示例                               |
| -------- | -------- | :--------------------------------------------------- | ---------------------------------- |
| UserCF   | 协同过滤 | 用户少， 物品多， 时效性较强的场合                   | 新闻推荐                           |
| ItemCF   | 协同过滤 | 物品少，用户多，用户兴趣固定持久，物品更新速度较慢。 | 推荐艺术品， 音乐， 电影           |
| Swing    | 协同过滤 | 寻找互补商品                                         | 用户完成购买行为以后，推荐互补商品 |
|          |          |                                                      |                                    |
|          |          |                                                      |                                    |
|          |          |                                                      |                                    |
|          |          |                                                      |                                    |





